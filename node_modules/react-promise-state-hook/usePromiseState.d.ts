/**
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
 */
export declare enum PromiseStatus {
    NOT_STARTED = 0,
    PENDING = 1,
    REJECTED = 2,
    FULFILLED = 3
}
/**
 * The possible result states as returned by {@link usePromiseState} are expressed by this type.
 *
 * This is useful for "type narrowing" in TypeScript usages. For example, if `result.status`
 * is `PromiseStatus.FULFILLED` then the type of `result.value` can be inferred as a
 * concrete type (the return type of the async callback).
 */
export declare type PromiseState<Resolved, Rejected> = {
    status: PromiseStatus.NOT_STARTED;
    value: null;
    err: null;
} | {
    status: PromiseStatus.PENDING;
    value: null;
    err: null;
} | {
    status: PromiseStatus.PENDING;
    value: Resolved;
    err: null;
} | {
    status: PromiseStatus.PENDING;
    value: null;
    err: Rejected;
} | {
    status: PromiseStatus.REJECTED;
    value: null;
    err: Rejected;
} | {
    status: PromiseStatus.FULFILLED;
    value: Resolved;
    err: null;
};
/**
 * Returns a wrapped version of the given async function that will never throw, and a stateful
 * object with the state of the promise returned from the function (NOT_STARTED, PENDING, FULFILLED,
 * REJECTED) and its resolved value or rejected value.
 *
 * The given async function can be memoized across renders using React.useCallback to prevent
 * unnecessary renders. If the function is not memoized, the returned wrapper function will have
 * a different identity on every render.
 *
 * The returned wrapper function is de-bounced across calls, meaning if it is called twice without
 * waiting for the first call to complete, the second call will have no effect.
 */
export declare const usePromiseState: <Params extends unknown[], Resolved>(asyncFn: (...params: Params) => Promise<Resolved>, { onError }?: {
    onError?: ((err: unknown) => void) | undefined;
}) => [(...params: Params) => Promise<void>, PromiseState<Resolved, unknown>];
/**
 * Create a {@link usePromiseState} hook with predefined default options.
 */
export declare const createUsePromiseState: (predefinedOptions: {
    onError?: ((err: unknown) => void) | undefined;
}) => <Params extends unknown[], Resolved>(asyncFn: (...params: Params) => Promise<Resolved>, options?: {
    onError?: ((err: unknown) => void) | undefined;
}) => [(...params: Params) => Promise<void>, PromiseState<Resolved, unknown>];
